"""
Agent Orchestrator MCP - Coordinateur principal du syst√®me
==========================================================

Agent principal qui :
- Scanne un r√©pertoire et identifie tous les files
- Distribue les files aux agents sp√©cialis√©s selon leur type :
  * Texte (.txt, .pdf, .md, .json, .csv) ‚Üí Agent NLP
  * Images (.jpg, .jpeg, .png, .gif, .bmp) ‚Üí Agent Vision
  * Audio (.mp3, .wav, .m4a, .ogg) ‚Üí Agent Audio
- Collecte tous les r√©sultats via l'Agent File Manager
- Coordonne la s√©curisation via l'Agent Security

Communication Agent-to-Agent via MCP Server.
"""

import asyncio
import json
import logging
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import mimetypes

# Imports MCP officiels
from mcp.server.fastmcp import FastMCP
from mcp.server.fastmcp import Context
from mcp.types import TextContent
from pydantic import BaseModel, Field

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/orchestrator.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Mod√®les de donn√©es pour la communication inter-agents
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class FileInfo(BaseModel):
    """Information sur un fichier √† traiter"""
    file_path: str
    file_type: str  # 'text', 'image', 'audio'
    mime_type: str
    size: int
    extension: str

class AgentTask(BaseModel):
    """T√¢che assign√©e √† un agent sp√©cialis√©"""
    agent_type: str  # 'nlp', 'vision', 'audio'
    files: List[FileInfo]
    task_id: str
    priority: int = 1

class ProcessingResult(BaseModel):
    """R√©sultat standardis√© de traitement (format unifi√©)"""
    file_path: str
    summary: str
    warning: bool
    agent_type: str
    processing_time: float
    metadata: Dict[str, Any] = {}

class OrchestrationReport(BaseModel):
    """Rapport complet d'orchestration"""
    session_id: str
    start_time: str
    end_time: str
    directory_scanned: str
    total_files: int
    files_by_type: Dict[str, int]
    results: List[ProcessingResult]
    files_with_warnings: List[str]
    security_actions: List[Dict[str, Any]] = []

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Classe principale de l'Orchestrator
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class AgentOrchestrator:
    """Agent Orchestrator - Coordinateur principal du syst√®me multi-agents"""
    
    def __init__(self):
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.supported_extensions = {
            # Fichiers texte ‚Üí Agent NLP
            'text': ['.txt', '.pdf', '.md', '.json', '.csv', '.xml', '.html', '.log', '.py', '.js', '.css'],
            # Fichiers image ‚Üí Agent Vision  
            'image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg'],
            # Fichiers audio ‚Üí Agent Audio
            'audio': ['.mp3', '.wav', '.m4a', '.ogg', '.flac', '.aac', '.mp4']
        }
        
        # Endpoints des agents sp√©cialis√©s (communication MCP)
        self.agent_endpoints = {
            'nlp': 'http://localhost:8001',
            'vision': 'http://localhost:8002', 
            'audio': 'http://localhost:8003',
            'file_manager': 'http://localhost:8004',
            'security': 'http://localhost:8005'
        }
        
        # Statistiques de session
        self.stats = {
            'files_scanned': 0,
            'files_processed': 0,
            'files_with_warnings': 0,
            'processing_errors': 0
        }
        
        logger.info(f"üéØ Agent Orchestrator initialis√© - Session: {self.session_id}")
    
    def classify_file(self, file_path: str) -> Optional[FileInfo]:
        """
        Classifie un fichier selon son type et d√©termine l'agent appropri√©
        
        Args:
            file_path: Chemin vers le fichier
            
        Returns:
            FileInfo si le fichier est support√©, None sinon
        """
        try:
            path_obj = Path(file_path)
            
            if not path_obj.exists() or not path_obj.is_file():
                return None
                
            extension = path_obj.suffix.lower()
            file_size = path_obj.stat().st_size
            
            # D√©terminer le type de fichier
            file_type = None
            for category, extensions in self.supported_extensions.items():
                if extension in extensions:
                    file_type = category
                    break
            
            if file_type is None:
                logger.debug(f"‚ö†Ô∏è Type de fichier non support√©: {extension}")
                return None
            
            # D√©terminer le MIME type
            mime_type, _ = mimetypes.guess_type(file_path)
            if mime_type is None:
                mime_type = f"application/{file_type}"
            
            return FileInfo(
                file_path=str(path_obj.resolve()),
                file_type=file_type,
                mime_type=mime_type,
                size=file_size,
                extension=extension
            )
            
        except Exception as e:
            logger.error(f"‚ùå Erreur classification fichier {file_path}: {e}")
            return None
    
    def scan_directory(self, directory_path: str, recursive: bool = True) -> Dict[str, List[FileInfo]]:
        """
        Scanne un r√©pertoire et classifie tous les files par type
        
        Args:
            directory_path: R√©pertoire √† scanner
            recursive: Scan r√©cursif des sous-dossiers
            
        Returns:
            Dictionnaire des files class√©s par type d'agent
        """
        logger.info(f"üîç Scan du r√©pertoire: {directory_path} (r√©cursif: {recursive})")
        
        directory = Path(directory_path)
        if not directory.exists():
            raise FileNotFoundError(f"R√©pertoire non trouv√©: {directory_path}")
        
        files_by_agent = {'nlp': [], 'vision': [], 'audio': []}
        
        # Pattern de recherche
        pattern = "**/*" if recursive else "*"
        
        for file_path in directory.glob(pattern):
            if file_path.is_file():
                self.stats['files_scanned'] += 1
                
                file_info = self.classify_file(str(file_path))
                if file_info:
                    # Mapper le type de fichier vers l'agent appropri√©
                    agent_type = 'nlp' if file_info.file_type == 'text' else file_info.file_type
                    if agent_type == 'image':
                        agent_type = 'vision'
                    
                    files_by_agent[agent_type].append(file_info)
                    logger.debug(f"üìÅ {file_info.extension} ‚Üí Agent {agent_type}: {file_path.name}")
        
        # Statistiques du scan
        total_classified = sum(len(files) for files in files_by_agent.values())
        logger.info(f"üìä Scan termin√©:")
        logger.info(f"   ‚Ä¢ {self.stats['files_scanned']} files scann√©s")
        logger.info(f"   ‚Ä¢ {total_classified} files classifi√©s")
        logger.info(f"   ‚Ä¢ NLP: {len(files_by_agent['nlp'])} files")
        logger.info(f"   ‚Ä¢ Vision: {len(files_by_agent['vision'])} files") 
        logger.info(f"   ‚Ä¢ Audio: {len(files_by_agent['audio'])} files")
        
        return files_by_agent
    
    async def dispatch_to_agent(self, agent_type: str, files: List[FileInfo]) -> List[ProcessingResult]:
        """
        Envoie les files √† l'agent sp√©cialis√© correspondant
        
        Args:
            agent_type: Type d'agent ('nlp', 'vision', 'audio')
            files: Liste des files √† traiter
            
        Returns:
            Liste des r√©sultats de traitement
        """
        if not files:
            return []
        
        logger.info(f"üì§ Dispatch vers Agent {agent_type.upper()}: {len(files)} files")
        
        results = []
        
        # Import dynamique de l'agent appropri√© selon le type
        try:
            if agent_type == 'nlp':
                # Utiliser l'agent NLP existant
                from agent_nlp_mcp import process_file_with_ai
                
                for file_info in files:
                    try:
                        start_time = datetime.now()
                        
                        # Appel de l'agent NLP (format attendu: dict avec file_path, summary, warning)
                        result_dict = await process_file_with_ai(file_info.file_path)
                        
                        processing_time = (datetime.now() - start_time).total_seconds()
                        
                        result = ProcessingResult(
                            file_path=result_dict.get('file_path', file_info.file_path),
                            summary=result_dict.get('summary', 'Trait√© par Agent NLP'),
                            warning=result_dict.get('warning', False),
                            agent_type='nlp',
                            processing_time=processing_time,
                            metadata={'file_size': file_info.size, 'mime_type': file_info.mime_type}
                        )
                        
                        results.append(result)
                        self.stats['files_processed'] += 1
                        
                        if result.warning:
                            self.stats['files_with_warnings'] += 1
                        
                        logger.info(f"‚úÖ NLP: {Path(file_info.file_path).name} - Warning: {result.warning}")
                        
                    except Exception as e:
                        logger.error(f"‚ùå Erreur Agent NLP pour {file_info.file_path}: {e}")
                        self.stats['processing_errors'] += 1
            
            elif agent_type == 'vision':
                # Utiliser l'agent Vision (√† adapter)
                from agent_vision_mcp import analyze_document, VisionArgs
                
                for file_info in files:
                    try:
                        start_time = datetime.now()
                        
                        # Appel de l'agent Vision
                        args = VisionArgs(path=file_info.file_path)
                        vision_result = await analyze_document(args)
                        
                        processing_time = (datetime.now() - start_time).total_seconds()
                        
                        result = ProcessingResult(
                            file_path=vision_result.filepath,
                            summary=vision_result.summary,
                            warning=vision_result.warning,
                            agent_type='vision',
                            processing_time=processing_time,
                            metadata={'file_size': file_info.size, 'mime_type': file_info.mime_type}
                        )
                        
                        results.append(result)
                        self.stats['files_processed'] += 1
                        
                        if result.warning:
                            self.stats['files_with_warnings'] += 1
                        
                        logger.info(f"‚úÖ Vision: {Path(file_info.file_path).name} - Warning: {result.warning}")
                        
                    except Exception as e:
                        logger.error(f"‚ùå Erreur Agent Vision pour {file_info.file_path}: {e}")
                        self.stats['processing_errors'] += 1
            
            elif agent_type == 'audio':
                # Utiliser l'agent Audio (√† cr√©er)
                from agent_audio_mcp import analyze_audio, AudioArgs
                
                for file_info in files:
                    try:
                        start_time = datetime.now()
                        
                        # Appel de l'agent Audio
                        args = AudioArgs(path=file_info.file_path)
                        audio_result = await analyze_audio(args)
                        
                        processing_time = (datetime.now() - start_time).total_seconds()
                        
                        result = ProcessingResult(
                            file_path=audio_result.filepath,
                            summary=audio_result.summary,
                            warning=audio_result.warning,
                            agent_type='audio',
                            processing_time=processing_time,
                            metadata={'file_size': file_info.size, 'mime_type': file_info.mime_type}
                        )
                        
                        results.append(result)
                        self.stats['files_processed'] += 1
                        
                        if result.warning:
                            self.stats['files_with_warnings'] += 1
                        
                        logger.info(f"‚úÖ Audio: {Path(file_info.file_path).name} - Warning: {result.warning}")
                        
                    except Exception as e:
                        logger.error(f"‚ùå Erreur Agent Audio pour {file_info.file_path}: {e}")
                        self.stats['processing_errors'] += 1
            
        except ImportError as e:
            logger.error(f"‚ùå Impossible d'importer l'agent {agent_type}: {e}")
            self.stats['processing_errors'] += len(files)
        
        logger.info(f"üì• Agent {agent_type.upper()} termin√©: {len(results)} r√©sultats")
        return results
    
    async def send_to_file_manager(self, results: List[ProcessingResult]) -> Dict[str, Any]:
        """
        Envoie tous les r√©sultats √† l'Agent File Manager pour consolidation
        
        Args:
            results: Liste de tous les r√©sultats de traitement
            
        Returns:
            Rapport consolid√© du File Manager
        """
        logger.info(f"üìã Envoi vers File Manager: {len(results)} r√©sultats")
        
        try:
            # Import de l'agent File Manager
            from agent_file_manager_mcp import consolidate_results
            
            # Pr√©parer les donn√©es pour le File Manager
            manager_input = {
                'session_id': self.session_id,
                'results': [result.dict() for result in results],
                'stats': self.stats
            }
            
            # Appel du File Manager
            consolidated_report = await consolidate_results(manager_input)
            
            logger.info("‚úÖ File Manager: Consolidation termin√©e")
            return consolidated_report
            
        except ImportError as e:
            logger.error(f"‚ùå Agent File Manager non disponible: {e}")
            return {'error': f'File Manager non disponible: {e}'}
        except Exception as e:
            logger.error(f"‚ùå Erreur File Manager: {e}")
            return {'error': f'Erreur File Manager: {e}'}
    
    async def send_to_security(self, warning_files: List[ProcessingResult]) -> List[Dict[str, Any]]:
        """
        Envoie les files avec warnings √† l'Agent Security pour s√©curisation
        
        Args:
            warning_files: Liste des r√©sultats avec warning=True
            
        Returns:
            Liste des actions de s√©curisation effectu√©es
        """
        if not warning_files:
            logger.info("üîí Aucun fichier n√©cessitant une s√©curisation")
            return []
        
        logger.info(f"üîí Envoi vers Security Agent: {len(warning_files)} files sensibles")
        
        try:
            # Import de l'agent Security
            from agent_security_mcp import secure_files
            
            # Pr√©parer les donn√©es pour l'agent Security
            security_input = {
                'session_id': self.session_id,
                'sensitive_files': [result.dict() for result in warning_files]
            }
            
            # Appel de l'agent Security
            security_actions = await secure_files(security_input)
            
            logger.info(f"‚úÖ Security Agent: {len(security_actions)} actions effectu√©es")
            return security_actions
            
        except ImportError as e:
            logger.error(f"‚ùå Agent Security non disponible: {e}")
            return [{'error': f'Security Agent non disponible: {e}'}]
        except Exception as e:
            logger.error(f"‚ùå Erreur Security Agent: {e}")
            return [{'error': f'Erreur Security Agent: {e}'}]
    
    async def orchestrate_directory(self, directory_path: str, recursive: bool = True) -> OrchestrationReport:
        """
        Orchestration compl√®te d'un r√©pertoire
        
        Args:
            directory_path: R√©pertoire √† traiter
            recursive: Scan r√©cursif
            
        Returns:
            Rapport complet d'orchestration
        """
        start_time = datetime.now()
        logger.info(f"üéØ === D√âBUT ORCHESTRATION ===")
        logger.info(f"üìÅ R√©pertoire: {directory_path}")
        logger.info(f"üîÑ Session: {self.session_id}")
        
        try:
            # 1. Scanner et classifier les files
            files_by_agent = self.scan_directory(directory_path, recursive)
            
            # 2. Traitement en parall√®le par les agents sp√©cialis√©s
            all_results = []
            
            # Dispatching en parall√®le vers les 3 agents
            tasks = []
            for agent_type, files in files_by_agent.items():
                if files:  # Seulement si des files sont pr√©sents
                    task = self.dispatch_to_agent(agent_type, files)
                    tasks.append(task)
            
            # Attendre tous les agents en parall√®le
            if tasks:
                results_lists = await asyncio.gather(*tasks, return_exceptions=True)
                
                for result_list in results_lists:
                    if isinstance(result_list, list):
                        all_results.extend(result_list)
                    else:
                        logger.error(f"‚ùå Erreur dans un agent: {result_list}")
            
            # 3. Envoyer √† l'Agent File Manager
            file_manager_report = await self.send_to_file_manager(all_results)
            
            # 4. Identifier les files avec warning et les s√©curiser
            warning_files = [r for r in all_results if r.warning]
            security_actions = await self.send_to_security(warning_files)
            
            # 5. G√©n√©rer le rapport final
            end_time = datetime.now()
            
            # Compter les files par type
            files_by_type = {}
            for agent_type, files in files_by_agent.items():
                files_by_type[agent_type] = len(files)
            
            report = OrchestrationReport(
                session_id=self.session_id,
                start_time=start_time.isoformat(),
                end_time=end_time.isoformat(),
                directory_scanned=directory_path,
                total_files=self.stats['files_scanned'],
                files_by_type=files_by_type,
                results=all_results,
                files_with_warnings=[r.file_path for r in warning_files],
                security_actions=security_actions
            )
            
            # Sauvegarder le rapport
            self.save_orchestration_report(report)
            
            # Log final
            duration = (end_time - start_time).total_seconds()
            logger.info(f"üéØ === ORCHESTRATION TERMIN√âE ===")
            logger.info(f"‚è±Ô∏è Dur√©e: {duration:.2f}s")
            logger.info(f"üìÅ Fichiers trait√©s: {self.stats['files_processed']}/{self.stats['files_scanned']}")
            logger.info(f"‚ö†Ô∏è Fichiers sensibles: {self.stats['files_with_warnings']}")
            logger.info(f"‚ùå Erreurs: {self.stats['processing_errors']}")
            
            return report
            
        except Exception as e:
            logger.error(f"‚ùå Erreur critique d'orchestration: {e}")
            end_time = datetime.now()
            
            # Rapport d'erreur
            error_report = OrchestrationReport(
                session_id=self.session_id,
                start_time=start_time.isoformat(),
                end_time=end_time.isoformat(),
                directory_scanned=directory_path,
                total_files=0,
                files_by_type={},
                results=[],
                files_with_warnings=[],
                security_actions=[{'error': str(e)}]
            )
            
            return error_report
    
    def save_orchestration_report(self, report: OrchestrationReport):
        """Sauvegarde le rapport d'orchestration"""
        try:
            os.makedirs("results", exist_ok=True)
            
            filename = f"orchestration_report_{self.session_id}.json"
            filepath = os.path.join("results", filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(report.dict(), f, indent=2, ensure_ascii=False)
            
            logger.info(f"üíæ Rapport sauvegard√©: {filepath}")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde rapport: {e}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# FastMCP Server pour l'exposition des outils
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Instance globale de l'orchestrator
orchestrator = AgentOrchestrator()

# Serveur MCP
mcp = FastMCP("Agent Orchestrator")

@mcp.tool()
async def orchestrate_directory(directory_path: str, recursive: bool = True) -> dict:
    """
    Orchestre le traitement complet d'un r√©pertoire via le syst√®me multi-agents
    
    Args:
        directory_path: Chemin du r√©pertoire √† traiter
        recursive: Scanner r√©cursivement les sous-dossiers
        
    Returns:
        Rapport complet d'orchestration avec tous les r√©sultats
    """
    try:
        report = await orchestrator.orchestrate_directory(directory_path, recursive)
        return report.dict()
    except Exception as e:
        logger.error(f"‚ùå Erreur tool orchestrate_directory: {e}")
        return {'error': str(e)}

@mcp.tool()
async def get_supported_extensions() -> dict:
    """
    Retourne la liste des extensions support√©es par chaque agent
    
    Returns:
        Dictionnaire des extensions support√©es par agent
    """
    return orchestrator.supported_extensions

@mcp.tool()
async def get_session_stats() -> dict:
    """
    Retourne les statistiques de la session courante
    
    Returns:
        Statistiques de traitement
    """
    return {
        'session_id': orchestrator.session_id,
        'stats': orchestrator.stats,
        'agent_endpoints': orchestrator.agent_endpoints
    }

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Interface CLI principale
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def main():
    """Interface en ligne de commande principale"""
    import sys
    
    if len(sys.argv) < 2:
        print("Agent Orchestrator - Syst√®me Multi-Agents MCP")
        print("=" * 50)
        print("\nUsage:")
        print("  python agent_orchestrator_mcp.py <directory>                # Traite un r√©pertoire")
        print("  python agent_orchestrator_mcp.py <directory> --no-recursive # Scan non-r√©cursif") 
        print("\nExemples:")
        print("  python agent_orchestrator_mcp.py ./documents")
        print("  python agent_orchestrator_mcp.py ./test_files --no-recursive")
        print("\nLe syst√®me dispatche automatiquement:")
        print("  üìù Fichiers texte (.txt, .pdf, .md...) ‚Üí Agent NLP")
        print("  üñºÔ∏è Fichiers image (.jpg, .png...) ‚Üí Agent Vision")
        print("  üéµ Fichiers audio (.mp3, .wav...) ‚Üí Agent Audio")
        print("  üìã Consolidation ‚Üí Agent File Manager")
        print("  üîí S√©curisation ‚Üí Agent Security")
        return
    
    directory = sys.argv[1]
    recursive = "--no-recursive" not in sys.argv
    
    print(f"\nüéØ Agent Orchestrator - Traitement Multi-Agents")
    print(f"üìÅ R√©pertoire: {directory}")
    print(f"üîÑ R√©cursif: {recursive}")
    print("=" * 60)
    
    # Cr√©er et lancer l'orchestration
    orchestrator_instance = AgentOrchestrator()
    report = await orchestrator_instance.orchestrate_directory(directory, recursive)
    
    # Afficher le r√©sum√©
    print(f"\nüìä === R√âSUM√â FINAL ===")
    print(f"üìÅ Fichiers scann√©s: {report.total_files}")
    print(f"üìù NLP: {report.files_by_type.get('nlp', 0)} files")
    print(f"üñºÔ∏è Vision: {report.files_by_type.get('vision', 0)} files")
    print(f"üéµ Audio: {report.files_by_type.get('audio', 0)} files")
    print(f"‚ö†Ô∏è Fichiers sensibles: {len(report.files_with_warnings)}")
    print(f"üîí Actions s√©curit√©: {len(report.security_actions)}")
    
    if report.files_with_warnings:
        print(f"\n‚ö†Ô∏è Fichiers n√©cessitant attention:")
        for warning_file in report.files_with_warnings[:5]:  # Top 5
            print(f"   ‚Ä¢ {Path(warning_file).name}")
        if len(report.files_with_warnings) > 5:
            print(f"   ‚Ä¢ ... et {len(report.files_with_warnings) - 5} autres")
    
    print(f"\nüíæ Rapport complet: results/orchestration_report_{report.session_id}.json")

if __name__ == "__main__":
    asyncio.run(main())
