"""
üöÄ Gestionnaire du Syst√®me MCP Multi-Agents R√©el
===============================================

Gestionnaire principal pour d√©marrer/arr√™ter tous les agents MCP.
"""

import asyncio
import json
import logging
import os
import sys
import signal
import subprocess
import time
import psutil
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime
import httpx

# Ajout du r√©pertoire parent au path pour les imports
sys.path.append(str(Path(__file__).parent))

from config import Config

# Configuration du logging
logging.basicConfig(
    level=getattr(logging, Config.LOG_LEVEL),
    format=Config.LOG_FORMAT,
    handlers=[
        logging.FileHandler(Config.LOGS_DIR / "system_manager.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class RealMCPSystemManager:
    """Gestionnaire du syst√®me MCP multi-agents r√©el"""
    
    def __init__(self):
        self.base_dir = Path(__file__).parent
        self.agents_dir = self.base_dir / "agents"
        self.processes = {}  # PID des processus agents
        self.agent_configs = Config.AGENTS
        
        logger.info(f"üöÄ Gestionnaire Syst√®me MCP initialis√©")
    
    def check_dependencies(self) -> bool:
        """V√©rifier les d√©pendances du syst√®me"""
        logger.info("üîç V√©rification des d√©pendances...")
        
        # V√©rifier les fichiers agents
        missing_agents = []
        for agent_name, config in self.agent_configs.items():
            script_path = self.agents_dir / config.script
            if not script_path.exists():
                missing_agents.append(f"{agent_name} ({config.script})")
        
        if missing_agents:
            logger.error(f"‚ùå Agents manquants: {', '.join(missing_agents)}")
            return False
        
        # V√©rifier les ports disponibles
        occupied_ports = []
        for agent_name, config in self.agent_configs.items():
            if self.is_port_occupied(config.port):
                occupied_ports.append(f"{agent_name}:{config.port}")
        
        if occupied_ports:
            logger.warning(f"‚ö†Ô∏è Ports occup√©s: {', '.join(occupied_ports)}")
            # Arr√™ter les processus sur ces ports
            for agent_name, config in self.agent_configs.items():
                if self.is_port_occupied(config.port):
                    self.kill_process_on_port(config.port)
        
        # V√©rifier Python et d√©pendances
        try:
            import fastapi
            import httpx
            import pydantic
            logger.info("‚úÖ D√©pendances Python disponibles")
        except ImportError as e:
            logger.error(f"‚ùå D√©pendances manquantes: {e}")
            return False
        
        logger.info("‚úÖ V√©rification des d√©pendances termin√©e")
        return True
    
    def is_port_occupied(self, port: int) -> bool:
        """V√©rifier si un port est occup√©"""
        try:
            for conn in psutil.net_connections():
                if hasattr(conn, 'laddr') and conn.laddr and conn.laddr.port == port:
                    return True
        except (psutil.AccessDenied, AttributeError):
            pass
        return False
    
    def kill_process_on_port(self, port: int):
        """Tuer le processus utilisant un port"""
        try:
            for conn in psutil.net_connections():
                if (hasattr(conn, 'laddr') and conn.laddr and 
                    conn.laddr.port == port and hasattr(conn, 'pid') and conn.pid):
                    try:
                        process = psutil.Process(conn.pid)
                        process.terminate()
                        logger.info(f"üî™ Processus {conn.pid} arr√™t√© sur le port {port}")
                        time.sleep(1)
                        if process.is_running():
                            process.kill()
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
        except Exception as e:
            logger.error(f"‚ùå Erreur arr√™t processus port {port}: {e}")
    
    def start_agent(self, agent_name: str) -> bool:
        """D√©marrer un agent sp√©cifique"""
        if agent_name not in self.agent_configs:
            logger.error(f"‚ùå Agent inconnu: {agent_name}")
            return False
        
        config = self.agent_configs[agent_name]
        if not config.enabled:
            logger.info(f"‚è∏Ô∏è Agent {agent_name} d√©sactiv√©")
            return True
        
        script_path = self.agents_dir / config.script
        if not script_path.exists():
            logger.error(f"‚ùå Script non trouv√©: {script_path}")
            return False
        
        # V√©rifier si d√©j√† en cours
        if agent_name in self.processes:
            pid = self.processes[agent_name]
            try:
                if psutil.Process(pid).is_running():
                    logger.info(f"üü° Agent {agent_name} d√©j√† en cours (PID: {pid})")
                    return True
            except psutil.NoSuchProcess:
                del self.processes[agent_name]
        
        # Arr√™ter tout processus sur le port
        if self.is_port_occupied(config.port):
            self.kill_process_on_port(config.port)
            time.sleep(2)
        
        try:
            # D√©marrer l'agent
            logger.info(f"üöÄ D√©marrage agent {agent_name} sur port {config.port}...")
            
            process = subprocess.Popen(
                [sys.executable, str(script_path)],
                cwd=str(script_path.parent),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE
            )
            
            self.processes[agent_name] = process.pid
            
            # Attendre un peu pour voir si le processus d√©marre correctement
            time.sleep(3)
            
            if process.poll() is None:  # Processus toujours en cours
                logger.info(f"‚úÖ Agent {agent_name} d√©marr√© (PID: {process.pid})")
                return True
            else:
                # Processus s'est arr√™t√©
                stdout, stderr = process.communicate()
                logger.error(f"‚ùå Agent {agent_name} s'est arr√™t√© imm√©diatement")
                logger.error(f"STDOUT: {stdout.decode()}")
                logger.error(f"STDERR: {stderr.decode()}")
                if agent_name in self.processes:
                    del self.processes[agent_name]
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur d√©marrage agent {agent_name}: {e}")
            return False
    
    def stop_agent(self, agent_name: str) -> bool:
        """Arr√™ter un agent sp√©cifique"""
        if agent_name not in self.processes:
            logger.info(f"‚è∏Ô∏è Agent {agent_name} n'est pas en cours")
            return True
        
        try:
            pid = self.processes[agent_name]
            process = psutil.Process(pid)
            
            # Tentative d'arr√™t propre
            process.terminate()
            
            # Attendre un peu
            try:
                process.wait(timeout=5)
            except psutil.TimeoutExpired:
                # Forcer l'arr√™t
                process.kill()
                process.wait(timeout=5)
            
            del self.processes[agent_name]
            logger.info(f"üõë Agent {agent_name} arr√™t√©")
            return True
            
        except psutil.NoSuchProcess:
            del self.processes[agent_name]
            logger.info(f"üõë Agent {agent_name} n'√©tait plus en cours")
            return True
        except Exception as e:
            logger.error(f"‚ùå Erreur arr√™t agent {agent_name}: {e}")
            return False
    
    def start_all_agents(self) -> Dict[str, bool]:
        """D√©marrer tous les agents"""
        logger.info("üöÄ D√©marrage de tous les agents...")
        
        results = {}
        
        # Ordre de d√©marrage sp√©cifique
        start_order = ['orchestrator', 'nlp', 'vision', 'audio', 'file_manager', 'security']
        
        for agent_name in start_order:
            if agent_name in self.agent_configs:
                success = self.start_agent(agent_name)
                results[agent_name] = success
                if success:
                    # Attendre un peu entre les d√©marrages
                    time.sleep(2)
        
        successful = sum(1 for success in results.values() if success)
        total = len(results)
        
        logger.info(f"üìä R√©sultat: {successful}/{total} agents d√©marr√©s")
        
        return results
    
    def stop_all_agents(self) -> Dict[str, bool]:
        """Arr√™ter tous les agents"""
        logger.info("üõë Arr√™t de tous les agents...")
        
        results = {}
        
        # Arr√™ter dans l'ordre inverse
        for agent_name in list(self.processes.keys()):
            success = self.stop_agent(agent_name)
            results[agent_name] = success
        
        logger.info("‚úÖ Tous les agents arr√™t√©s")
        return results
    
    async def check_agents_health(self) -> Dict[str, Dict[str, Any]]:
        """V√©rifier la sant√© de tous les agents"""
        health_status = {}
        
        for agent_name, config in self.agent_configs.items():
            if not config.enabled:
                health_status[agent_name] = {
                    "status": "disabled",
                    "port": config.port,
                    "endpoint": None
                }
                continue
            
            endpoint = f"http://localhost:{config.port}/health"
            
            try:
                async with httpx.AsyncClient(timeout=5.0) as client:
                    response = await client.get(endpoint)
                    
                    if response.status_code == 200:
                        health_status[agent_name] = {
                            "status": "healthy",
                            "port": config.port,
                            "endpoint": endpoint,
                            "response": response.json()
                        }
                    else:
                        health_status[agent_name] = {
                            "status": "unhealthy",
                            "port": config.port,
                            "endpoint": endpoint,
                            "error": f"HTTP {response.status_code}"
                        }
                        
            except Exception as e:
                health_status[agent_name] = {
                    "status": "unreachable",
                    "port": config.port,
                    "endpoint": endpoint,
                    "error": str(e)
                }
        
        return health_status
    
    def get_system_status(self) -> Dict[str, Any]:
        """Obtenir le statut complet du syst√®me"""
        status = {
            "timestamp": datetime.now().isoformat(),
            "running_agents": len(self.processes),
            "total_agents": len([c for c in self.agent_configs.values() if c.enabled]),
            "processes": {},
            "ports": {}
        }
        
        # Statut des processus
        for agent_name, pid in self.processes.items():
            try:
                process = psutil.Process(pid)
                status["processes"][agent_name] = {
                    "pid": pid,
                    "status": process.status(),
                    "cpu_percent": process.cpu_percent(),
                    "memory_mb": process.memory_info().rss / (1024 * 1024),
                    "create_time": datetime.fromtimestamp(process.create_time()).isoformat()
                }
            except psutil.NoSuchProcess:
                status["processes"][agent_name] = {
                    "pid": pid,
                    "status": "not_found"
                }
        
        # Statut des ports
        for agent_name, config in self.agent_configs.items():
            status["ports"][agent_name] = {
                "port": config.port,
                "occupied": self.is_port_occupied(config.port),
                "enabled": config.enabled
            }
        
        return status
    
    async def run_test_workflow(self) -> Dict[str, Any]:
        """Ex√©cuter un workflow de test complet"""
        logger.info("üß™ D√©marrage du workflow de test...")
        
        # 1. V√©rifier la sant√© des agents
        health = await self.check_agents_health()
        healthy_agents = [name for name, status in health.items() if status["status"] == "healthy"]
        
        logger.info(f"‚úÖ Agents en sant√©: {', '.join(healthy_agents)}")
        
        # 2. Test de l'orchestrateur si disponible
        if "orchestrator" in healthy_agents:
            try:
                test_dir = Config.DATA_DIR / "test_files"
                if test_dir.exists():
                    async with httpx.AsyncClient(timeout=60.0) as client:
                        response = await client.post(
                            f"http://localhost:8001/orchestrate",
                            json={"directory_path": str(test_dir)}
                        )
                        
                        if response.status_code == 200:
                            logger.info("‚úÖ Test orchestrateur r√©ussi")
                        else:
                            logger.error(f"‚ùå Test orchestrateur √©chou√©: {response.status_code}")
            except Exception as e:
                logger.error(f"‚ùå Erreur test orchestrateur: {e}")
        
        return {
            "health_status": health,
            "test_completed": True,
            "timestamp": datetime.now().isoformat()
        }

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Interface CLI
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def main():
    """Interface principale du gestionnaire"""
    manager = RealMCPSystemManager()
    
    if len(sys.argv) < 2:
        print("""
üöÄ Gestionnaire Syst√®me MCP Multi-Agents R√©el

Usage:
  python system_manager.py start        # D√©marrer tous les agents
  python system_manager.py stop         # Arr√™ter tous les agents
  python system_manager.py restart      # Red√©marrer tous les agents
  python system_manager.py status       # Statut du syst√®me
  python system_manager.py health       # Sant√© des agents
  python system_manager.py test         # Workflow de test
  python system_manager.py check        # V√©rifier les d√©pendances
        """)
        return
    
    command = sys.argv[1].lower()
    
    try:
        if command == "check":
            success = manager.check_dependencies()
            if success:
                print("‚úÖ Toutes les d√©pendances sont disponibles")
            else:
                print("‚ùå Certaines d√©pendances manquent")
                sys.exit(1)
        
        elif command == "start":
            manager.check_dependencies()
            results = manager.start_all_agents()
            
            successful = sum(1 for success in results.values() if success)
            total = len(results)
            
            print(f"\nüìä R√©sultat du d√©marrage: {successful}/{total} agents")
            for agent, success in results.items():
                status = "‚úÖ" if success else "‚ùå"
                print(f"  {status} {agent}")
            
            if successful == total:
                print("\nüéâ Tous les agents sont d√©marr√©s!")
                print("\nüåê Endpoints disponibles:")
                for agent_name, config in manager.agent_configs.items():
                    if config.enabled and results.get(agent_name, False):
                        print(f"  ‚Ä¢ {agent_name}: http://localhost:{config.port}")
            
        elif command == "stop":
            results = manager.stop_all_agents()
            print("üõë Tous les agents ont √©t√© arr√™t√©s")
        
        elif command == "restart":
            print("üîÑ Red√©marrage du syst√®me...")
            manager.stop_all_agents()
            time.sleep(3)
            manager.check_dependencies()
            results = manager.start_all_agents()
            
            successful = sum(1 for success in results.values() if success)
            total = len(results)
            print(f"‚úÖ Red√©marrage termin√©: {successful}/{total} agents")
        
        elif command == "status":
            status = manager.get_system_status()
            print(f"\nüìä Statut du Syst√®me - {status['timestamp']}")
            print(f"Agents en cours: {status['running_agents']}/{status['total_agents']}")
            
            print("\nüîß Processus:")
            for agent, proc_info in status['processes'].items():
                if proc_info['status'] != 'not_found':
                    print(f"  ‚Ä¢ {agent}: PID {proc_info['pid']}, CPU {proc_info.get('cpu_percent', 0):.1f}%, RAM {proc_info.get('memory_mb', 0):.1f}MB")
                else:
                    print(f"  ‚Ä¢ {agent}: Processus introuvable")
            
            print("\nüåê Ports:")
            for agent, port_info in status['ports'].items():
                status_icon = "üü¢" if port_info['occupied'] else "üî¥"
                enabled_text = "activ√©" if port_info['enabled'] else "d√©sactiv√©"
                print(f"  ‚Ä¢ {agent}: Port {port_info['port']} {status_icon} ({enabled_text})")
        
        elif command == "health":
            health = await manager.check_agents_health()
            print("\nüè• Sant√© des Agents:")
            
            for agent, health_info in health.items():
                status = health_info['status']
                if status == "healthy":
                    print(f"  ‚úÖ {agent}: Sain (port {health_info['port']})")
                elif status == "disabled":
                    print(f"  ‚è∏Ô∏è {agent}: D√©sactiv√©")
                elif status == "unhealthy":
                    print(f"  ‚ö†Ô∏è {agent}: Probl√®me - {health_info.get('error', 'Inconnu')}")
                elif status == "unreachable":
                    print(f"  ‚ùå {agent}: Injoignable - {health_info.get('error', 'Inconnu')}")
        
        elif command == "test":
            print("üß™ Ex√©cution du workflow de test...")
            result = await manager.run_test_workflow()
            
            print("\nüìã R√©sultats du test:")
            for agent, health_info in result['health_status'].items():
                status = health_info['status']
                status_icon = {"healthy": "‚úÖ", "disabled": "‚è∏Ô∏è", "unhealthy": "‚ö†Ô∏è", "unreachable": "‚ùå"}.get(status, "‚ùì")
                print(f"  {status_icon} {agent}: {status}")
            
            if result['test_completed']:
                print("\nüéâ Workflow de test termin√© avec succ√®s!")
        
        else:
            print(f"‚ùå Commande inconnue: {command}")
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Interruption par l'utilisateur")
        manager.stop_all_agents()
    except Exception as e:
        logger.error(f"‚ùå Erreur: {e}")
        print(f"‚ùå Erreur: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
