#!/usr/bin/env python3
"""
Security Agent - Version Simplifi√©e
Agent de s√©curit√© avec chiffrement et interface Streamlit

Usage:
    python security_agent.py

Fonctionnalit√©s:
- Chiffrement/d√©chiffrement de fichiers
- Interface Streamlit simple
- Int√©gration Llama 3.2 pour les explications
- Authentification par phrase secr√®te
"""

import os
import sys
import sqlite3
import hashlib
import uuid
import secrets
import subprocess
import threading
import time
import requests
import json
from pathlib import Path
from datetime import datetime
import tempfile

# Configuration
BASE_DIR = Path(__file__).parent
VAULT_DIR = BASE_DIR / "vault"
ENCRYPTED_DIR = BASE_DIR / "encrypted"
DECRYPTED_DIR = BASE_DIR / "decrypted"

# Cr√©er les r√©pertoires
VAULT_DIR.mkdir(exist_ok=True)
ENCRYPTED_DIR.mkdir(exist_ok=True)
DECRYPTED_DIR.mkdir(exist_ok=True)

VAULT_DB = VAULT_DIR / "vault.db"
SECRET_PHRASE = "mon_secret_ultra_securise_2024"  # Phrase secr√®te pour l'authentification

# ================================
# INSTALLATION DES D√âPENDANCES
# ================================

def install_dependencies():
    """Installe les d√©pendances n√©cessaires"""
    print("üîç V√©rification des d√©pendances...")
    
    packages = ["streamlit", "pyAesCrypt", "requests", "pandas"]
    
    for package in packages:
        try:
            __import__(package)
            print(f"   ‚úÖ {package}")
        except ImportError:
            print(f"   üì¶ Installation de {package}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    
    print("‚úÖ D√©pendances OK")

# Installation des d√©pendances
install_dependencies()

# Imports apr√®s installation
import streamlit as st
import pyAesCrypt
import pandas as pd

# ================================
# GESTIONNAIRE OLLAMA
# ================================

class OllamaManager:
    """Gestionnaire Ollama pour les explications IA"""
    
    def __init__(self):
        self.model_name = "llama3.2:1b"
        self.ollama_url = "http://localhost:11434"
        self.is_running = False
        
    def check_ollama_installed(self):
        """V√©rifie si Ollama est install√©"""
        try:
            result = subprocess.run(["ollama", "--version"], capture_output=True, text=True)
            return result.returncode == 0
        except FileNotFoundError:
            return False
    
    def install_ollama(self):
        """Installe Ollama"""
        print("üì¶ Installation d'Ollama...")
        try:
            if sys.platform == "darwin":  # macOS
                subprocess.run(["curl", "-fsSL", "https://ollama.com/install.sh", "|", "sh"], shell=True)
            elif sys.platform == "linux":
                subprocess.run(["curl", "-fsSL", "https://ollama.com/install.sh", "|", "sh"], shell=True)
            else:  # Windows
                print("‚ö†Ô∏è  Veuillez installer Ollama manuellement depuis https://ollama.com")
                return False
            return True
        except Exception as e:
            print(f"‚ùå Erreur installation Ollama: {e}")
            return False
    
    def start_ollama(self):
        """D√©marre Ollama"""
        if not self.check_ollama_installed():
            if not self.install_ollama():
                return False
        
        try:
            # D√©marrer Ollama en arri√®re-plan
            subprocess.Popen(["ollama", "serve"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(3)  # Attendre le d√©marrage
            
            # V√©rifier si le mod√®le est disponible
            self.pull_model()
            self.is_running = True
            return True
        except Exception as e:
            print(f"‚ùå Erreur d√©marrage Ollama: {e}")
            return False
    
    def pull_model(self):
        """T√©l√©charge le mod√®le Llama 3.2"""
        try:
            print(f"üì• T√©l√©chargement du mod√®le {self.model_name}...")
            subprocess.run(["ollama", "pull", self.model_name], check=True)
            print("‚úÖ Mod√®le t√©l√©charg√©")
        except Exception as e:
            print(f"‚ùå Erreur t√©l√©chargement mod√®le: {e}")
    
    def generate_explanation(self, action, file_path, details=""):
        """G√©n√®re une explication avec Llama"""
        if not self.is_running:
            return f"ü§ñ {action} effectu√©e sur {file_path}. {details}"
        
        try:
            prompt = f"""Tu es un assistant de s√©curit√©. Explique simplement ce qui vient de se passer:

Action: {action}
Fichier: {file_path}
D√©tails: {details}

R√©ponds en fran√ßais, de mani√®re claire et rassurante, en 2-3 phrases maximum."""

            response = requests.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": self.model_name,
                    "prompt": prompt,
                    "stream": False
                },
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                return f"ü§ñ {result.get('response', 'Explication non disponible')}"
            else:
                return f"ü§ñ {action} effectu√©e sur {file_path}. {details}"
                
        except Exception as e:
            return f"ü§ñ {action} effectu√©e sur {file_path}. {details}"

# ================================
# GESTIONNAIRE DE VAULT
# ================================

class VaultManager:
    """Gestionnaire du vault de s√©curit√©"""
    
    def __init__(self):
        self.init_database()
        self.master_key = self.get_master_key()
    
    def init_database(self):
        """Initialise la base de donn√©es"""
        conn = sqlite3.connect(str(VAULT_DB))
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vault_entries (
                uuid TEXT PRIMARY KEY,
                original_path TEXT NOT NULL,
                encrypted_path TEXT NOT NULL,
                filename TEXT NOT NULL,
                created_at TEXT NOT NULL,
                file_hash TEXT NOT NULL,
                file_size INTEGER NOT NULL
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def get_master_key(self):
        """G√©n√®re ou r√©cup√®re la cl√© ma√Ætre"""
        key_file = VAULT_DIR / "master.key"
        
        if key_file.exists():
            with open(key_file, 'r') as f:
                return f.read().strip()
        else:
            # G√©n√©rer une nouvelle cl√©
            key = secrets.token_urlsafe(32)
            with open(key_file, 'w') as f:
                f.write(key)
            return key
    
    def calculate_file_hash(self, file_path):
        """Calcule le hash d'un fichier"""
        hasher = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hasher.update(chunk)
        return hasher.hexdigest()
    
    def encrypt_file(self, file_path):
        """Chiffre un fichier"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Fichier non trouv√©: {file_path}")
        
        # G√©n√©rer UUID et chemins
        file_uuid = str(uuid.uuid4())
        filename = os.path.basename(file_path)
        encrypted_path = ENCRYPTED_DIR / f"{file_uuid}.aes"
        
        # Chiffrer le fichier
        pyAesCrypt.encryptFile(file_path, str(encrypted_path), self.master_key)
        
        # Sauvegarder dans la base
        conn = sqlite3.connect(str(VAULT_DB))
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vault_entries (uuid, original_path, encrypted_path, filename, created_at, file_hash, file_size)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            file_uuid,
            file_path,
            str(encrypted_path),
            filename,
            datetime.now().isoformat(),
            self.calculate_file_hash(file_path),
            os.path.getsize(file_path)
        ))
        
        conn.commit()
        conn.close()
        
        return {
            "uuid": file_uuid,
            "filename": filename,
            "encrypted_path": str(encrypted_path),
            "original_path": file_path
        }
    
    def decrypt_file(self, file_uuid, output_path=None):
        """D√©chiffre un fichier"""
        conn = sqlite3.connect(str(VAULT_DB))
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM vault_entries WHERE uuid = ?', (file_uuid,))
        row = cursor.fetchone()
        conn.close()
        
        if not row:
            raise ValueError(f"Fichier non trouv√© dans le vault: {file_uuid}")
        
        uuid, original_path, encrypted_path, filename, created_at, file_hash, file_size = row
        
        if not output_path:
            output_path = DECRYPTED_DIR / f"{filename}"
        
        # D√©chiffrer
        pyAesCrypt.decryptFile(encrypted_path, str(output_path), self.master_key)
        
        return {
            "uuid": uuid,
            "filename": filename,
            "decrypted_path": str(output_path),
            "original_path": original_path
        }
    
    def list_files(self):
        """Liste tous les fichiers dans le vault"""
        conn = sqlite3.connect(str(VAULT_DB))
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM vault_entries ORDER BY created_at DESC')
        rows = cursor.fetchall()
        conn.close()
        
        files = []
        for row in rows:
            files.append({
                "uuid": row[0],
                "filename": row[3],
                "original_path": row[1],
                "created_at": row[4],
                "file_size": row[6]
            })
        
        return files
    
    def get_stats(self):
        """Statistiques du vault"""
        conn = sqlite3.connect(str(VAULT_DB))
        cursor = conn.cursor()
        
        cursor.execute('SELECT COUNT(*), SUM(file_size) FROM vault_entries')
        count, total_size = cursor.fetchone()
        
        conn.close()
        
        return {
            "total_files": count or 0,
            "total_size": total_size or 0
        }

# ================================
# INTERFACE STREAMLIT
# ================================

def main():
    """Interface principale Streamlit"""
    st.set_page_config(
        page_title="üîê Security Agent",
        page_icon="üîê",
        layout="wide"
    )
    
    st.title("üîê Security Agent - Chiffrement de Fichiers")
    st.markdown("---")
    
    # Initialiser les managers
    if 'vault_manager' not in st.session_state:
        st.session_state.vault_manager = VaultManager()
    
    if 'ollama_manager' not in st.session_state:
        st.session_state.ollama_manager = OllamaManager()
        # D√©marrer Ollama en arri√®re-plan
        if not st.session_state.ollama_manager.is_running:
            with st.spinner("üöÄ D√©marrage d'Ollama..."):
                st.session_state.ollama_manager.start_ollama()
    
    # Sidebar pour les stats
    with st.sidebar:
        st.header("üìä Statistiques")
        stats = st.session_state.vault_manager.get_stats()
        st.metric("Fichiers chiffr√©s", stats["total_files"])
        st.metric("Taille totale", f"{stats['total_size']:,} bytes")
        
        st.markdown("---")
        st.header("üîë Phrase secr√®te")
        st.info(f"Phrase actuelle: `{SECRET_PHRASE}`")
        st.caption("Cette phrase est n√©cessaire pour d√©chiffrer les fichiers")
    
    # Tabs principales
    tab1, tab2, tab3 = st.tabs(["üîí Chiffrement", "üîì D√©chiffrement", "üìÅ Fichiers"])
    
    with tab1:
        st.header("üîí Chiffrer un fichier")
        
        # Input pour le chemin du fichier
        file_path = st.text_input("üìÇ Chemin du fichier √† chiffrer:", placeholder="/path/to/your/file.txt")
        
        if st.button("üîí Chiffrer le fichier", type="primary"):
            if not file_path:
                st.error("‚ùå Veuillez saisir un chemin de fichier")
            elif not os.path.exists(file_path):
                st.error(f"‚ùå Fichier non trouv√©: {file_path}")
            else:
                try:
                    with st.spinner("üîÑ Chiffrement en cours..."):
                        # Chiffrer le fichier
                        result = st.session_state.vault_manager.encrypt_file(file_path)
                        
                        # G√©n√©rer l'explication avec Llama
                        explanation = st.session_state.ollama_manager.generate_explanation(
                            "Chiffrement",
                            file_path,
                            f"Le fichier a √©t√© chiffr√© avec succ√®s et stock√© dans le vault s√©curis√© avec l'UUID {result['uuid']}"
                        )
                        
                        # Afficher les r√©sultats
                        st.success("‚úÖ Fichier chiffr√© avec succ√®s!")
                        
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.info("üìã Informations du fichier")
                            st.write(f"**Nom:** {result['filename']}")
                            st.write(f"**UUID:** {result['uuid']}")
                            st.write(f"**Chemin chiffr√©:** {result['encrypted_path']}")
                        
                        with col2:
                            st.info("ü§ñ Explication IA")
                            st.write(explanation)
                        
                        st.warning("‚ö†Ô∏è Gardez pr√©cieusement l'UUID pour pouvoir d√©chiffrer le fichier plus tard!")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du chiffrement: {e}")
    
    with tab2:
        st.header("üîì D√©chiffrer un fichier")
        
        # Authentification
        secret_input = st.text_input("üîë Phrase secr√®te:", type="password", placeholder="Saisissez la phrase secr√®te")
        
        if secret_input == SECRET_PHRASE:
            st.success("‚úÖ Authentification r√©ussie!")
            
            # Liste des fichiers disponibles
            files = st.session_state.vault_manager.list_files()
            
            if files:
                file_options = {f"{file['filename']} ({file['uuid'][:8]}...)": file['uuid'] for file in files}
                selected_file = st.selectbox("üìÅ S√©lectionnez un fichier √† d√©chiffrer:", options=list(file_options.keys()))
                
                if st.button("üîì D√©chiffrer le fichier", type="primary"):
                    try:
                        with st.spinner("üîÑ D√©chiffrement en cours..."):
                            selected_uuid = file_options[selected_file]
                            result = st.session_state.vault_manager.decrypt_file(selected_uuid)
                            
                            # G√©n√©rer l'explication avec Llama
                            explanation = st.session_state.ollama_manager.generate_explanation(
                                "D√©chiffrement",
                                result['filename'],
                                f"Le fichier a √©t√© d√©chiffr√© avec succ√®s et est maintenant disponible dans le dossier 'decrypted'"
                            )
                            
                            # Afficher les r√©sultats
                            st.success("‚úÖ Fichier d√©chiffr√© avec succ√®s!")
                            
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                st.info("üìã Informations du fichier")
                                st.write(f"**Nom:** {result['filename']}")
                                st.write(f"**UUID:** {result['uuid']}")
                                st.write(f"**Chemin d√©chiffr√©:** {result['decrypted_path']}")
                            
                            with col2:
                                st.info("ü§ñ Explication IA")
                                st.write(explanation)
                            
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors du d√©chiffrement: {e}")
            else:
                st.info("üì≠ Aucun fichier chiffr√© dans le vault")
        
        elif secret_input:
            st.error("‚ùå Phrase secr√®te incorrecte!")
    
    with tab3:
        st.header("üìÅ Fichiers dans le vault")
        
        files = st.session_state.vault_manager.list_files()
        
        if files:
            # Convertir en DataFrame pour affichage
            df = pd.DataFrame(files)
            df['created_at'] = pd.to_datetime(df['created_at']).dt.strftime('%Y-%m-%d %H:%M:%S')
            df['file_size'] = df['file_size'].apply(lambda x: f"{x:,} bytes")
            
            st.dataframe(
                df[['filename', 'uuid', 'created_at', 'file_size']],
                use_container_width=True
            )
        else:
            st.info("üì≠ Aucun fichier dans le vault")

# ================================
# D√âMARRAGE
# ================================

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        # Mode test
        print("üß™ Mode test...")
        vm = VaultManager()
        print(f"‚úÖ Vault initialis√©: {vm.get_stats()}")
        
        # Cr√©er un fichier de test
        test_file = BASE_DIR / "test_file.txt"
        with open(test_file, 'w') as f:
            f.write("Ceci est un fichier de test pour le chiffrement.")
        
        # Tester le chiffrement
        result = vm.encrypt_file(str(test_file))
        print(f"‚úÖ Fichier chiffr√©: {result['uuid']}")
        
        # Tester le d√©chiffrement
        decrypted = vm.decrypt_file(result['uuid'])
        print(f"‚úÖ Fichier d√©chiffr√©: {decrypted['decrypted_path']}")
        
        # Nettoyer
        os.remove(test_file)
        print("‚úÖ Test termin√©")
    else:
        # Mode Streamlit
        main()
