"""
Agent Audio MCP avec capacit√©s IA compl√®tes - Version Agent Autonome
===================================================================

Agent Audio autonome MCP qui peut :
- Analyser des fichiers audio et d√©tecter les PII vocales avec intelligence contextuelle
- Transcription speech-to-text avec Whisper local
- D√©tection PII textuelle dans les transcriptions (email, t√©l√©phone, noms, adresses)
- R√©sum√© intelligent avec LLama-3 local via LangChain
- Exposer toutes ses capacit√©s via le protocole MCP officiel

Utilise Ollama/Llama + LangChain pour l'IA, Whisper pour la transcription, avec fallback intelligent.
Format de sortie standardis√©: {filepath, summary, warning}
"""

import asyncio
import json
import logging
import os
import sys
import warnings
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime
import re
import time

# Suppression des avertissements
warnings.filterwarnings("ignore", category=DeprecationWarning)

# Imports MCP officiels
from mcp.server.fastmcp import FastMCP
from mcp.server.fastmcp import Context
from mcp.types import TextContent
from pydantic import BaseModel, Field

# LangChain imports pour l'IA
try:
    from langchain_community.llms import Ollama
    from langchain.tools import tool
    LANGCHAIN_AVAILABLE = True
    print("‚úÖ LangChain disponible")
except ImportError:
    LANGCHAIN_AVAILABLE = False
    print("‚ö†Ô∏è LangChain non disponible")

# Whisper pour la transcription
try:
    import whisper
    WHISPER_AVAILABLE = True
    print("‚úÖ Whisper disponible")
except ImportError:
    WHISPER_AVAILABLE = False
    print("‚ö†Ô∏è Whisper non disponible")

# numpy pour les calculs
try:
    import numpy as np
    NUMPY_AVAILABLE = True
    print("‚úÖ NumPy disponible")
except ImportError:
    NUMPY_AVAILABLE = False
    print("‚ö†Ô∏è NumPy non disponible")

# Configuration du logging avec support Unicode pour Windows
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/audio_agent.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# Configuration Ollama/LLama
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
LLAMA_MODEL = os.getenv("LLAMA_MODEL", "llama3.2:latest")

# Initialisation du LLM
llm = None
if LANGCHAIN_AVAILABLE:
    try:
        llm = Ollama(
            model=LLAMA_MODEL,
            base_url=OLLAMA_BASE_URL,
            temperature=0.3  # Plus d√©terministe pour l'analyse audio
        )
        # Test de connexion
        test_response = llm.invoke("Test audio")
        logger.info("‚úÖ Ollama/Llama Audio connect√© avec succ√®s")
        print("‚úÖ Agent Audio IA Ollama/Llama pr√™t")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Connexion Ollama √©chou√©e: {e}")
        print(f"‚ö†Ô∏è Connexion Ollama √©chou√©e: {e}")
        llm = None

# Regex patterns pour la d√©tection PII dans les transcriptions
PII_REGEXES: Dict[str, re.Pattern] = {
    "EMAIL": re.compile(r"[\w\.\-]+@[\w\.-]+\.[a-z]{2,}", re.I),
    "PHONE": re.compile(r"\+?\d{1,3}[\s\-]?\d[\d\s\-]{8,}\d", re.I),
    "CARD": re.compile(r"\b\d{4}[\s\-]?\d{4}[\s\-]?\d{4}[\s\-]?\d{4}\b"),
    "IBAN": re.compile(r"\b[A-Z]{2}\d{2}[\s]?[A-Z0-9]{4}[\s]?\d{4}[\s]?\d{4}[\s]?\d{4}[\s]?\d{4}[\s]?\d{2}\b"),
    "SSN": re.compile(r"\b\d{3}-?\d{2}-?\d{4}\b"),
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Mod√®les de donn√©es
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class AudioArgs(BaseModel):
    """Arguments pour l'analyse audio"""
    path: str
    audio_bytes: Optional[bytes] = None

class AudioResponse(BaseModel):
    """R√©ponse standardis√©e de l'agent Audio (format unifi√© avec NLP/Vision)"""
    filepath: str
    summary: str
    warning: bool  # True = contient des informations sensibles

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Fonctions principales d'analyse audio
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def detect_pii_in_text(text: str) -> List[str]:
    """
    D√©tecte les PII dans le texte transcrit
    
    Args:
        text: Texte √† analyser
        
    Returns:
        Liste des types de PII d√©tect√©s
    """
    pii_detected = []
    
    for pii_type, pattern in PII_REGEXES.items():
        matches = pattern.findall(text)
        if matches:
            pii_detected.append(pii_type)
            logger.warning(f"‚ö†Ô∏è PII d√©tect√© dans la transcription: {pii_type} ({len(matches)} occurrences)")
    
    # D√©tection de mots-cl√©s sensibles sp√©cifiques √† l'audio
    sensitive_keywords = [
        "mot de passe", "password", "code secret", "pin", "carte bancaire",
        "num√©ro de carte", "compte en banque", "s√©curit√© sociale", "insee",
        "date de naissance", "n√© le", "n√©e le", "adresse", "je habite",
        "t√©l√©phone", "portable", "email", "mail", "skype", "whatsapp"
    ]
    
    text_lower = text.lower()
    for keyword in sensitive_keywords:
        if keyword in text_lower:
            pii_detected.append("SENSITIVE_KEYWORD")
            logger.warning(f"‚ö†Ô∏è Mot-cl√© sensible d√©tect√©: {keyword}")
            break
    
    return pii_detected

def transcribe_audio_simple(file_path: str) -> str:
    """
    Transcription audio simple avec fallback
    
    Args:
        file_path: Chemin du fichier audio
        
    Returns:
        Texte transcrit
    """
    try:
        if not WHISPER_AVAILABLE:
            logger.warning("‚ùå Whisper non disponible")
            return ""
        
        # Charger Whisper (mod√®le base pour bon compromis vitesse/qualit√©)
        logger.info(f"üéôÔ∏è Chargement mod√®le Whisper...")
        model = whisper.load_model("base")
        
        logger.info(f"üéôÔ∏è D√©but transcription: {Path(file_path).name}")
        
        # Transcription
        result = model.transcribe(file_path, language="fr")
        text = result.get("text", "").strip()
        
        logger.info(f"‚úÖ Transcription r√©ussie: {len(text)} caract√®res")
        if text:
            logger.info(f"üìù Aper√ßu: '{text[:100]}{'...' if len(text) > 100 else ''}'")
        
        return text
        
    except Exception as e:
        logger.error(f"‚ùå Erreur transcription: {e}")
        return ""

async def analyze_audio_with_ai(file_path: str, use_ai: bool = True) -> dict:
    """
    Analyse compl√®te d'un fichier audio avec IA (format standardis√©)
    
    Args:
        file_path: Chemin du fichier audio
        use_ai: Utiliser l'IA pour l'analyse (d√©faut: True)
        
    Returns:
        Dictionnaire avec filepath, summary, warning (format unifi√©)
    """
    try:
        logger.info(f"üéµ D√©but analyse audio: {file_path}")
        
        # V√©rifier l'existence du fichier
        if not os.path.exists(file_path):
            return {
                'filepath': file_path,
                'summary': 'Fichier audio non trouv√©',
                'warning': False
            }
        
        # V√©rifier le format
        supported_formats = ['.mp3', '.wav', '.m4a', '.ogg', '.flac', '.aac', '.mp4']
        file_ext = Path(file_path).suffix.lower()
        
        if file_ext not in supported_formats:
            return {
                'filepath': file_path,
                'summary': f'Format audio non support√©: {file_ext}',
                'warning': False
            }
        
        # Transcription
        transcription = transcribe_audio_simple(file_path)
        
        if not transcription:
            return {
                'filepath': str(Path(file_path).resolve()),
                'summary': 'Fichier audio analys√© mais transcription vide ou impossible',
                'warning': False
            }
        
        # D√©tection PII
        pii_detected = detect_pii_in_text(transcription)
        warning = len(pii_detected) > 0
        
        # Analyse avec IA si disponible
        if use_ai and llm and LANGCHAIN_AVAILABLE:
            try:
                prompt = f"""Analyse ce contenu audio transcrit et d√©termine s'il contient des informations sensibles.

Transcription: "{transcription}"

PII d√©tect√©s automatiquement: {', '.join(pii_detected) if pii_detected else 'Aucun'}

Fournis un r√©sum√© intelligent du contenu audio en fran√ßais.
Si des informations sensibles sont pr√©sentes, mentionne-le clairement dans le r√©sum√©.
Sois concis mais informatif.

R√©sum√©:"""

                ai_summary = llm.invoke(prompt)
                
                # Nettoyer la r√©ponse
                summary = ai_summary.strip()
                if len(summary) > 300:
                    summary = summary[:300] + "..."
                
                logger.info(f"‚úÖ Analyse IA audio termin√©e: {len(summary)} caract√®res")
                
            except Exception as e:
                logger.error(f"‚ùå Erreur analyse IA: {e}")
                summary = f"Transcription audio ({len(transcription)} caract√®res)"
                if warning:
                    summary += f" - Informations sensibles d√©tect√©es: {', '.join(pii_detected)}"
        else:
            # Fallback sans IA
            summary = f"Transcription audio ({len(transcription)} caract√®res)"
            if len(transcription) > 100:
                summary += f": {transcription[:100]}..."
            else:
                summary += f": {transcription}"
                
            if warning:
                summary += f" - ATTENTION: Informations sensibles d√©tect√©es: {', '.join(pii_detected)}"
        
        result = {
            'filepath': str(Path(file_path).resolve()),
            'summary': summary,
            'warning': warning
        }
        
        logger.info(f"üéØ Analyse audio termin√©e - Warning: {warning}")
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Erreur analyse audio: {e}")
        return {
            'filepath': file_path,
            'summary': f'Erreur analyse audio: {str(e)}',
            'warning': False
        }

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Fonction principale pour l'orchestrator (compatible avec agent_nlp)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def process_file_with_ai(file_path: str) -> dict:
    """
    Point d'entr√©e principal pour l'orchestrator - compatible avec agent_nlp
    
    Args:
        file_path: Chemin du fichier audio
        
    Returns:
        Dictionnaire avec file_path, summary, warning (format unifi√©)
    """
    result = await analyze_audio_with_ai(file_path, use_ai=True)
    
    # Assurer le format unifi√© (filepath ‚Üí file_path pour compatibilit√©)
    return {
        'file_path': result['filepath'],
        'summary': result['summary'],
        'warning': result['warning']
    }

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Serveur MCP FastMCP
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

mcp = FastMCP("Agent Audio MCP")

@mcp.tool()
async def analyze_audio(args: AudioArgs) -> dict:
    """
    Analyse un fichier audio et d√©tecte les informations sensibles
    
    Args:
        args: Arguments contenant le chemin du fichier audio
        
    Returns:
        Dictionnaire avec filepath, summary et warning
    """
    try:
        result = await analyze_audio_with_ai(args.path, use_ai=True)
        return result
    except Exception as e:
        logger.error(f"‚ùå Erreur tool analyze_audio: {e}")
        return {
            'filepath': args.path,
            'summary': f'Erreur analyse audio: {str(e)}',
            'warning': False
        }

@mcp.tool()
async def transcribe_audio_only(file_path: str) -> dict:
    """
    Transcrit uniquement un fichier audio sans analyse PII
    
    Args:
        file_path: Chemin du fichier audio
        
    Returns:
        Transcription du fichier audio
    """
    try:
        transcription = transcribe_audio_simple(file_path)
        return {
            'file_path': file_path,
            'transcription': transcription,
            'length': len(transcription)
        }
    except Exception as e:
        logger.error(f"‚ùå Erreur transcribe_audio_only: {e}")
        return {'error': str(e)}

@mcp.tool()
async def process_audio_file(file_path: str, use_ai: bool = True) -> dict:
    """
    Traite un fichier audio avec l'IA
    
    Args:
        file_path: Chemin du fichier audio
        use_ai: Utiliser l'IA pour l'analyse
        
    Returns:
        R√©sultat de l'analyse
    """
    try:
        result = await analyze_audio_with_ai(file_path, use_ai)
        return result
    except Exception as e:
        logger.error(f"‚ùå Erreur process_audio_file: {e}")
        return {'error': str(e)}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Interface CLI
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def main():
    """Interface en ligne de commande"""
    if len(sys.argv) < 2:
        print("Agent Audio MCP - Analyse de fichiers audio avec IA")
        print("=" * 50)
        print("\nUsage:")
        print("  python agent_audio_mcp.py <audio_file>        # Analyse compl√®te")
        print("  python agent_audio_mcp.py --server            # Lancer serveur MCP")
        print("\nFormats support√©s:")
        print("  ‚Ä¢ .mp3, .wav, .m4a, .ogg, .flac, .aac, .mp4")
        print("\nExemples:")
        print("  python agent_audio_mcp.py ./audio/meeting.mp3")
        print("  python agent_audio_mcp.py ./recordings/call.wav")
        return
    
    if sys.argv[1] == "--server":
        print("üéµ D√©marrage du serveur MCP Audio Agent...")
        await mcp.run()
        return
    
    # Analyse du fichier fourni
    audio_file = sys.argv[1]
    
    print(f"\nüéµ Agent Audio - Analyse de fichier")
    print(f"üìÅ Fichier: {audio_file}")
    print("=" * 50)
    
    result = await analyze_audio_with_ai(audio_file)
    
    print(f"\nüéØ === R√âSULTAT FINAL ===")
    print(f"üìÅ Filepath: {result['filepath']}")
    print(f"üìÑ Summary: {result['summary']}")
    print(f"‚ö†Ô∏è Warning: {result['warning']}")
    
    print(f"\n{'=' * 50}")
    print("‚úÖ Analyse termin√©e")

if __name__ == "__main__":
    asyncio.run(main())
